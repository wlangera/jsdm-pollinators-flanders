---
title: "Test gllvm package"
author: "Ward Langeraert"
date: today
date-format: "D MMMM YYYY"
format:
  html:
    toc: true
    toc-depth: 3
    toc-location: left
editor_options: 
  chunk_output_type: console
---

# Goal

Test **gllvm** package on dataset.

```{r}
#| warning: false
#| message: false
# Packages
library(tidyverse)
library(gllvm)

# Conflicts
conflicted::conflicts_prefer(dplyr::filter)

# Paths
source_path <- here::here("source", "scripts")
data_path <- here::here("data", "processed")
cache_path <- here::here("source", "quarto", "cache", "gllvm_models")
dir.create(cache_path, showWarnings = FALSE, recursive = TRUE)

# Source
source(file.path(source_path, "plot_random_effects.R"))
source(file.path(source_path, "plot_variance_partitioning.R"))
```

# Load data

We only look at butterfly data to have not too many species.
Load observation data.

```{r}
butterflies_data_wide <- read_csv(
  file.path(data_path, "butterflies_data_wide.csv")
)
```

```{r}
dim(butterflies_data_wide)
```

Load plot data of with variables.

```{r}
plot_data_wide <- read_csv(
  file.path(data_path, "plot_data_wide.csv")
)

# Select plots of observations
plot_data_wide <- plot_data_wide %>%
  filter(habID %in% butterflies_data_wide$habID) %>%
  mutate(habClass = factor(habClass),
         habID = factor(habID))
```

# Data exploration

We just pick some species to look at the distribution of the counts.
We have a huge amount of zeroes.

```{r}
set.seed(123)
butterflies_data_wide %>%
  pivot_longer(cols = -habID, names_to = "species", values_to = "count") %>%
  count(species, count) %>%
  arrange(species, count) %>%
  filter(species %in% sample(names(butterflies_data_wide[-1]), 4)) %>%
  ggplot(aes(x = count, y = n)) +
  geom_bar(stat = "identity") +
  facet_wrap(~species, scales = "free") +
  theme_minimal()
```

# Test model fit
## Response distribution

We work with counts and we have zero inflation.
We fit a Poisson zero inflated model.

```{r}
if (file.exists(file.path(cache_path, "model1.Rds"))) {
  model1 <- readRDS(file.path(cache_path, "model1.Rds"))
} else {
  model1 <- gllvm(y = butterflies_data_wide[, -1], num.lv = 2, family = "ZIP",
                  sd.errors = FALSE)
  saveRDS(model1, file.path(cache_path, "model1.Rds"))
}
```

The QQ plot does not look good.

```{r}
plot(model1, which = 2)
```

The next logical step is to look at the zero inflated Negative Binomial distribution.

```{r}
if (file.exists(file.path(cache_path, "model2.Rds"))) {
  model2 <- readRDS(file.path(cache_path, "model2.Rds"))
} else {
  model2 <- gllvm(y = butterflies_data_wide[, -1], num.lv = 2, family = "ZINB",
                  sd.errors = FALSE)
  saveRDS(model2, file.path(cache_path, "model2.Rds"))
}
```

This looks good.

```{r}
plot(model2, which = 2)
```

## Sampling effort

We use plot size and total number of observations per plot to account for sampling effort.

<!-- spell-check: ignore:start -->

Let $y_{ij}$ be the count of species $j$ at site or observation unit $i$.
Assume:

$$
y_{ij} \sim \text{NegBin}(\mu_{ij}, \theta_{j})
$$

with

$$
\log(\mu_{ij}) = \log(\text{E}(y_{ij})) = \beta_{0j} + \beta_{\text{mixed},j} + \beta_{\text{wet},j} + \log(X_{\text{area},i}) + \log(X_{\text{effort},i})
$$

or equivalently, by offsetting:

$$
\log\left( \frac{\text{E}(y_{ij})}{X_{\text{area},i} \cdot X_{\text{effort},i}} \right) = \beta_{0j} + \beta_{\text{mixed},j} + \beta_{\text{wet},j}
$$

where:

* $\mu_{ij} = \mathbb{E}(y_{ij})$ is the expected count,
* $\theta_j$ is the dispersion parameter for species $j$,
* $X_{\text{area},i}$ and $X_{\text{effort},i}$ are offset terms (e.g. surveyed area and effort),
* All $\beta$'s are species-specific coefficients.

<!-- spell-check: ignore:end -->

```{r}
plot_data_wide$offset_var <- log(
  plot_data_wide$habAreaM2 * plot_data_wide$samplingEffort
)
```

We use the `offset` argument of the `gllvm()` function.

```{r}
if (file.exists(file.path(cache_path, "model3.Rds"))) {
  model3 <- readRDS(file.path(cache_path, "model3.Rds"))
} else {
  model3 <- gllvm(
    y = butterflies_data_wide[, -1],
    X = plot_data_wide,
    formula = ~habClass,
    offset = plot_data_wide$offset_var,
    num.lv = 2,
    family = "ZINB",
    sd.errors = TRUE
  )
  saveRDS(model3, file.path(cache_path, "model3.Rds"))
}
```

Model fit looks good.

```{r}
#| fig-height: 10
par(mfrow = c(3, 2))
plot(model3)
par(mfrow = c(1, 1))
```

We visualise the results:

```{r}
coefplot(model3)
par(mfrow = c(1, 1))
```

Looks like we have one species with big uncertainty.
We use a random effects model.

## Random effects model

```{r}
if (file.exists(file.path(cache_path, "model4.Rds"))) {
  model4 <- readRDS(file.path(cache_path, "model4.Rds"))
} else {
  model4 <- gllvm(
    y = butterflies_data_wide[, -1],
    X = plot_data_wide,
    formula = ~(habClass | 1),
    offset = plot_data_wide$offset_var,
    beta0com = TRUE, # collects fixed intercepts to single intercept
    num.lv = 2,
    family = "ZINB",
    sd.errors = TRUE
  )
  saveRDS(model4, file.path(cache_path, "model4.Rds"))
}
```

Model fit looks good.

```{r}
#| fig-height: 10
par(mfrow = c(3, 2))
plot(model4)
par(mfrow = c(1, 1))
```

We visualise the results:

```{r}
randomCoefplot(model4)
par(mfrow = c(1, 1))
```

```{r}
#| fig-height: 5
plot_random_effects(model4)
```

We look at variance partitioning.

```{r}
plot_variance_partitioning(model4)
```

This is probably due to the pseudo absences.
The latent variables do not explain anything.
The pseudo absences were created per polygon and therefore we expect more pseudo absences in smaller polygons than in larger polygons.
This is a problem.

# Ordination

```{r}
#| fig-height: 6
# Add colours
my_colors <- c("red", "green", "yellow")
col_vect <- my_colors[plot_data_wide$habClass]

# Make plot
ordiplot(model4, symbols = TRUE, biplot = TRUE,
         s.colors = col_vect, s.cex = 0.5, pch = 16)
legend(
  "topright",
  legend = levels(plot_data_wide$habClass),
  col = my_colors,
  pch = 16,
  cex = 1
)
```

# Account for spatial correlation

```{r}
if (file.exists(file.path(cache_path, "model5.Rds"))) {
  model5 <- readRDS(file.path(cache_path, "model5.Rds"))
} else {
  model5 <- gllvm(
    y = butterflies_data_wide[, -1],
    X = plot_data_wide,
    formula = ~(habClass | 1),
    beta0com = TRUE,
    studyDesign = as.data.frame(plot_data_wide[, "habID"]),
    row.eff = ~corExp(1 | habID),
    dist = as.matrix(plot_data_wide[, c("x", "y")]),
    offset = plot_data_wide$offset_var,
    num.lv = 2,
    family = "ZINB",
    sd.errors = TRUE,
    starting.val = "zero" # not necessary anymore with development version
  )
  saveRDS(model5, file.path(cache_path, "model5.Rds"))
}
```

Model fit looks good.

```{r}
#| fig-height: 10
par(mfrow = c(3, 2))
plot(model5)
par(mfrow = c(1, 1))
```

Our new model seems to be better.
A spatial model is always better.

```{r}
tibble(
  model = c("model4", "model5"),
  AIC = c(AIC(model4), AIC(model5)),
  AICc = c(AICc(model4), AICc(model5)),
  BIC = c(BIC(model4), BIC(model5))
) %>%
  arrange(AIC, AICc, BIC) %>%
  knitr::kable()
```

```{r}
rho1 <- model5$params$sigma[1]
```

However the spatial scale parameter is `r rho1`.
There is something weird going on.

```{r}
fun1 <- function(d) exp(-d / rho1)
curve(fun1, from = 0, to = rho1 * 5, xlab = "distance", ylab = "exp(-d/rho)",
      ylim = c(0, 1), main = "Spatial correlation")
abline(v = rho1, lty = 2)
```

This may be due to bad starting value. Change `rangeP` parameter. This can also be due to the fact that some polygons are next to each other and others are very far away.

How do the effects look like?

```{r}
#| fig-height: 5
plot_random_effects(model5)
```

We look at variance partitioning.

```{r}
plot_variance_partitioning(model5)
```

# Traits

```{r}
trait_data_interim <- read_csv(
  file.path(here::here("data", "intermediate"),
            "trait_data_interim.csv")
)
```

Are all species present in trait dataset?

```{r}
trait_species <- trait_data_interim %>%
  filter(pollinatorGroup == "butterflies") %>%
  pull(vernacularName)

setdiff(names(butterflies_data_wide[, -1]), trait_species)
```

No. We do not have trait data for `r length(setdiff(names(butterflies_data_wide[, -1]), trait_species))`.
